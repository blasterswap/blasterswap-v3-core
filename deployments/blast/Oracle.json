{
  "address": "0x379422f360B9886D5Ff4456f9Aa9192A9Eda84d8",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "time",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "a",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "b",
          "type": "uint32"
        }
      ],
      "name": "lte",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "blockTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "int56",
              "name": "tickCumulative",
              "type": "int56"
            },
            {
              "internalType": "uint160",
              "name": "secondsPerLiquidityCumulativeX128",
              "type": "uint160"
            },
            {
              "internalType": "bool",
              "name": "initialized",
              "type": "bool"
            }
          ],
          "internalType": "struct Oracle.Observation",
          "name": "last",
          "type": "tuple"
        },
        {
          "internalType": "uint32",
          "name": "blockTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        },
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "name": "transform",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "blockTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "int56",
              "name": "tickCumulative",
              "type": "int56"
            },
            {
              "internalType": "uint160",
              "name": "secondsPerLiquidityCumulativeX128",
              "type": "uint160"
            },
            {
              "internalType": "bool",
              "name": "initialized",
              "type": "bool"
            }
          ],
          "internalType": "struct Oracle.Observation",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0xc08d38bc6c26f6fcaae133d5a4e27d10e0c0c22252760956898621fdddb65e17",
  "receipt": {
    "to": null,
    "from": "0x14F3fC5Bd9F29fA60B84310cf6e5CfED67d75FB9",
    "contractAddress": "0x379422f360B9886D5Ff4456f9Aa9192A9Eda84d8",
    "transactionIndex": 14,
    "gasUsed": "1022076",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xb57227a100ef250c6f5c9860b5b033b9e09ca5f571e79c8c0e602c1adfdf2f25",
    "transactionHash": "0xc08d38bc6c26f6fcaae133d5a4e27d10e0c0c22252760956898621fdddb65e17",
    "logs": [],
    "blockNumber": 3041768,
    "cumulativeGasUsed": "4151577",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "df4b39deb5489a93004e3e7d31587f68",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"time\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"a\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"b\",\"type\":\"uint32\"}],\"name\":\"lte\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"int56\",\"name\":\"tickCumulative\",\"type\":\"int56\"},{\"internalType\":\"uint160\",\"name\":\"secondsPerLiquidityCumulativeX128\",\"type\":\"uint160\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct Oracle.Observation\",\"name\":\"last\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"name\":\"transform\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"int56\",\"name\":\"tickCumulative\",\"type\":\"int56\"},{\"internalType\":\"uint160\",\"name\":\"secondsPerLiquidityCumulativeX128\",\"type\":\"uint160\"},{\"internalType\":\"bool\",\"name\":\"initialized\",\"type\":\"bool\"}],\"internalType\":\"struct Oracle.Observation\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\",\"kind\":\"dev\",\"methods\":{\"binarySearch(Oracle.Observation[65535] storage,uint32,uint32,uint16,uint16)\":{\"details\":\"The answer must be contained in the array, used when the target is located within the stored observation boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\",\"params\":{\"cardinality\":\"The number of populated elements in the oracle array\",\"index\":\"The index of the observation that was most recently written to the observations array\",\"self\":\"The stored oracle array\",\"target\":\"The timestamp at which the reserved observation should be for\",\"time\":\"The current block.timestamp\"},\"returns\":{\"atOrAfter\":\"The observation recorded at, or after, the target\",\"beforeOrAt\":\"The observation recorded before, or at, the target\"}},\"getSurroundingObservations(Oracle.Observation[65535] storage,uint32,uint32,int24,uint16,uint128,uint16)\":{\"details\":\"Assumes there is at least 1 initialized observation. Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\",\"params\":{\"cardinality\":\"The number of populated elements in the oracle array\",\"index\":\"The index of the observation that was most recently written to the observations array\",\"liquidity\":\"The total pool liquidity at the time of the call\",\"self\":\"The stored oracle array\",\"target\":\"The timestamp at which the reserved observation should be for\",\"tick\":\"The active tick at the time of the returned or simulated observation\",\"time\":\"The current block.timestamp\"},\"returns\":{\"atOrAfter\":\"The observation which occurred at, or after, the given timestamp\",\"beforeOrAt\":\"The observation which occurred at, or before, the given timestamp\"}},\"grow(Oracle.Observation[65535] storage,uint16,uint16)\":{\"params\":{\"current\":\"The current next cardinality of the oracle array\",\"next\":\"The proposed next cardinality which will be populated in the oracle array\",\"self\":\"The stored oracle array\"},\"returns\":{\"_0\":\"next The next cardinality which will be populated in the oracle array\"}},\"initialize(Oracle.Observation[65535] storage,uint32)\":{\"params\":{\"self\":\"The stored oracle array\",\"time\":\"The time of the oracle initialization, via block.timestamp truncated to uint32\"},\"returns\":{\"cardinality\":\"The number of populated elements in the oracle array\",\"cardinalityNext\":\"The new length of the oracle array, independent of population\"}},\"lte(uint32,uint32,uint32)\":{\"details\":\"safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\",\"params\":{\"a\":\"A comparison timestamp from which to determine the relative position of `time`\",\"b\":\"From which to determine the relative position of `time`\",\"time\":\"A timestamp truncated to 32 bits\"},\"returns\":{\"_0\":\"bool Whether `a` is chronologically <= `b`\"}},\"observe(Oracle.Observation[65535] storage,uint32,uint32[],int24,uint16,uint128,uint16)\":{\"details\":\"Reverts if `secondsAgos` > oldest observation\",\"params\":{\"cardinality\":\"The number of populated elements in the oracle array\",\"index\":\"The index of the observation that was most recently written to the observations array\",\"liquidity\":\"The current in-range pool liquidity\",\"secondsAgos\":\"Each amount of time to look back, in seconds, at which point to return an observation\",\"self\":\"The stored oracle array\",\"tick\":\"The current tick\",\"time\":\"The current block.timestamp\"},\"returns\":{\"secondsPerLiquidityCumulativeX128s\":\"The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\",\"tickCumulatives\":\"The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\"}},\"observeSingle(Oracle.Observation[65535] storage,uint32,uint32,int24,uint16,uint128,uint16)\":{\"details\":\"Reverts if an observation at or before the desired observation timestamp does not exist. 0 may be passed as `secondsAgo' to return the current cumulative values. If called with a timestamp falling between two observations, returns the counterfactual accumulator values at exactly the timestamp between the two observations.\",\"params\":{\"cardinality\":\"The number of populated elements in the oracle array\",\"index\":\"The index of the observation that was most recently written to the observations array\",\"liquidity\":\"The current in-range pool liquidity\",\"secondsAgo\":\"The amount of time to look back, in seconds, at which point to return an observation\",\"self\":\"The stored oracle array\",\"tick\":\"The current tick\",\"time\":\"The current block timestamp\"},\"returns\":{\"secondsPerLiquidityCumulativeX128\":\"The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\",\"tickCumulative\":\"The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\"}},\"transform(Oracle.Observation,uint32,int24,uint128)\":{\"details\":\"blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\",\"params\":{\"blockTimestamp\":\"The timestamp of the new observation\",\"last\":\"The specified observation to be transformed\",\"liquidity\":\"The total in-range liquidity at the time of the new observation\",\"tick\":\"The active tick at the time of the new observation\"},\"returns\":{\"_0\":\"Observation The newly populated observation\"}},\"write(Oracle.Observation[65535] storage,uint16,uint32,int24,uint128,uint16,uint16)\":{\"details\":\"Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally. If the index is at the end of the allowable array length (according to cardinality), and the next cardinality is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\",\"params\":{\"blockTimestamp\":\"The timestamp of the new observation\",\"cardinality\":\"The number of populated elements in the oracle array\",\"cardinalityNext\":\"The new length of the oracle array, independent of population\",\"index\":\"The index of the observation that was most recently written to the observations array\",\"liquidity\":\"The total in-range liquidity at the time of the new observation\",\"self\":\"The stored oracle array\",\"tick\":\"The active tick at the time of the new observation\"},\"returns\":{\"cardinalityUpdated\":\"The new cardinality of the oracle array\",\"indexUpdated\":\"The new index of the most recently written element in the oracle array\"}}},\"title\":\"Oracle\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"binarySearch(Oracle.Observation[65535] storage,uint32,uint32,uint16,uint16)\":{\"notice\":\"Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied. The result may be the same observation, or adjacent observations.\"},\"getSurroundingObservations(Oracle.Observation[65535] storage,uint32,uint32,int24,uint16,uint128,uint16)\":{\"notice\":\"Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\"},\"grow(Oracle.Observation[65535] storage,uint16,uint16)\":{\"notice\":\"Prepares the oracle array to store up to `next` observations\"},\"initialize(Oracle.Observation[65535] storage,uint32)\":{\"notice\":\"Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\"},\"lte(uint32,uint32,uint32)\":{\"notice\":\"comparator for 32-bit timestamps\"},\"observe(Oracle.Observation[65535] storage,uint32,uint32[],int24,uint16,uint128,uint16)\":{\"notice\":\"Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\"},\"transform(Oracle.Observation,uint32,int24,uint128)\":{\"notice\":\"Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\"},\"write(Oracle.Observation[65535] storage,uint16,uint32,int24,uint128,uint16,uint16)\":{\"notice\":\"Writes an oracle observation to the array\"}},\"notice\":\"Provides price and liquidity data useful for a wide variety of system designs\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/libraries/Oracle.sol\":\"Oracle\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100},\"remappings\":[]},\"sources\":{\"contracts/libraries/Oracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity >=0.5.0 <0.8.0;\\npragma abicoder v2;\\n\\n/// @title Oracle\\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\\n/// @dev Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array\\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\\n/// Observations are overwritten when the full length of the oracle array is populated.\\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\\nlibrary Oracle {\\n    struct Observation {\\n        // the block timestamp of the observation\\n        uint32 blockTimestamp;\\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\\n        int56 tickCumulative;\\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\\n        uint160 secondsPerLiquidityCumulativeX128;\\n        // whether or not the observation is initialized\\n        bool initialized;\\n    }\\n\\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\\n    /// @param last The specified observation to be transformed\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param tick The active tick at the time of the new observation\\n    /// @param liquidity The total in-range liquidity at the time of the new observation\\n    /// @return Observation The newly populated observation\\n    function transform(\\n        Observation memory last,\\n        uint32 blockTimestamp,\\n        int24 tick,\\n        uint128 liquidity\\n    ) public pure returns (Observation memory) {\\n        uint32 delta = blockTimestamp - last.blockTimestamp;\\n        return\\n            Observation({\\n                blockTimestamp: blockTimestamp,\\n                tickCumulative: last.tickCumulative + int56(tick) * delta,\\n                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\\n                    ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\\n                initialized: true\\n            });\\n    }\\n\\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\\n    /// @param self The stored oracle array\\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\\n    /// @return cardinality The number of populated elements in the oracle array\\n    /// @return cardinalityNext The new length of the oracle array, independent of population\\n    function initialize(Observation[65535] storage self, uint32 time)\\n        public\\n        returns (uint16 cardinality, uint16 cardinalityNext)\\n    {\\n        self[0] = Observation({\\n            blockTimestamp: time,\\n            tickCumulative: 0,\\n            secondsPerLiquidityCumulativeX128: 0,\\n            initialized: true\\n        });\\n        return (1, 1);\\n    }\\n\\n    /// @notice Writes an oracle observation to the array\\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\\n    /// @param self The stored oracle array\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param tick The active tick at the time of the new observation\\n    /// @param liquidity The total in-range liquidity at the time of the new observation\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @param cardinalityNext The new length of the oracle array, independent of population\\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\\n    /// @return cardinalityUpdated The new cardinality of the oracle array\\n    function write(\\n        Observation[65535] storage self,\\n        uint16 index,\\n        uint32 blockTimestamp,\\n        int24 tick,\\n        uint128 liquidity,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    ) public returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\\n        Observation memory last = self[index];\\n\\n        // early return if we've already written an observation this block\\n        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\\n\\n        // if the conditions are right, we can bump the cardinality\\n        if (cardinalityNext > cardinality && index == (cardinality - 1)) {\\n            cardinalityUpdated = cardinalityNext;\\n        } else {\\n            cardinalityUpdated = cardinality;\\n        }\\n\\n        indexUpdated = (index + 1) % cardinalityUpdated;\\n        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\\n    }\\n\\n    /// @notice Prepares the oracle array to store up to `next` observations\\n    /// @param self The stored oracle array\\n    /// @param current The current next cardinality of the oracle array\\n    /// @param next The proposed next cardinality which will be populated in the oracle array\\n    /// @return next The next cardinality which will be populated in the oracle array\\n    function grow(\\n        Observation[65535] storage self,\\n        uint16 current,\\n        uint16 next\\n    ) public returns (uint16) {\\n        require(current > 0, 'I');\\n        // no-op if the passed next value isn't greater than the current next value\\n        if (next <= current) return current;\\n        // store in each slot to prevent fresh SSTOREs in swaps\\n        // this data will not be used because the initialized boolean is still false\\n        for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\\n        return next;\\n    }\\n\\n    /// @notice comparator for 32-bit timestamps\\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\\n    /// @param time A timestamp truncated to 32 bits\\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\\n    /// @param b From which to determine the relative position of `time`\\n    /// @return bool Whether `a` is chronologically <= `b`\\n    function lte(\\n        uint32 time,\\n        uint32 a,\\n        uint32 b\\n    ) public pure returns (bool) {\\n        // if there hasn't been overflow, no need to adjust\\n        if (a <= time && b <= time) return a <= b;\\n\\n        uint256 aAdjusted = a > time ? a : a + 2**32;\\n        uint256 bAdjusted = b > time ? b : b + 2**32;\\n\\n        return aAdjusted <= bAdjusted;\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\\n    /// The result may be the same observation, or adjacent observations.\\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation recorded before, or at, the target\\n    /// @return atOrAfter The observation recorded at, or after, the target\\n    function binarySearch(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 target,\\n        uint16 index,\\n        uint16 cardinality\\n    ) public view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        uint256 l = (index + 1) % cardinality; // oldest observation\\n        uint256 r = l + cardinality - 1; // newest observation\\n        uint256 i;\\n        while (true) {\\n            i = (l + r) / 2;\\n\\n            beforeOrAt = self[i % cardinality];\\n\\n            // we've landed on an uninitialized tick, keep searching higher (more recently)\\n            if (!beforeOrAt.initialized) {\\n                l = i + 1;\\n                continue;\\n            }\\n\\n            atOrAfter = self[(i + 1) % cardinality];\\n\\n            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\\n\\n            // check if we've found the answer!\\n            if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\\n\\n            if (!targetAtOrAfter) r = i - 1;\\n            else l = i + 1;\\n        }\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\\n    /// @dev Assumes there is at least 1 initialized observation.\\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param tick The active tick at the time of the returned or simulated observation\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The total pool liquidity at the time of the call\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\\n    function getSurroundingObservations(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 target,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) public view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        // optimistically set before to the newest observation\\n        beforeOrAt = self[index];\\n\\n        // if the target is chronologically at or after the newest observation, we can early return\\n        if (lte(time, beforeOrAt.blockTimestamp, target)) {\\n            if (beforeOrAt.blockTimestamp == target) {\\n                // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\\n                return (beforeOrAt, atOrAfter);\\n            } else {\\n                // otherwise, we need to transform\\n                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\\n            }\\n        }\\n\\n        // now, set before to the oldest observation\\n        beforeOrAt = self[(index + 1) % cardinality];\\n        if (!beforeOrAt.initialized) beforeOrAt = self[0];\\n\\n        // ensure that the target is chronologically at or after the oldest observation\\n        require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');\\n\\n        // if we've reached this point, we have to binary search\\n        return binarySearch(self, time, target, index, cardinality);\\n    }\\n\\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\\n    /// at exactly the timestamp between the two observations.\\n    /// @param self The stored oracle array\\n    /// @param time The current block timestamp\\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\\n    /// @param tick The current tick\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The current in-range pool liquidity\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\\n    function observeSingle(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 secondsAgo,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) public view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\\n        if (secondsAgo == 0) {\\n            Observation memory last = self[index];\\n            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\\n            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\\n        }\\n\\n        uint32 target = time - secondsAgo;\\n\\n        (Observation memory beforeOrAt, Observation memory atOrAfter) =\\n            getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);\\n\\n        if (target == beforeOrAt.blockTimestamp) {\\n            // we're at the left boundary\\n            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\\n        } else if (target == atOrAfter.blockTimestamp) {\\n            // we're at the right boundary\\n            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\\n        } else {\\n            // we're in the middle\\n            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\\n            uint32 targetDelta = target - beforeOrAt.blockTimestamp;\\n            return (\\n                beforeOrAt.tickCumulative +\\n                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / observationTimeDelta) *\\n                    targetDelta,\\n                beforeOrAt.secondsPerLiquidityCumulativeX128 +\\n                    uint160(\\n                        (uint256(\\n                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128\\n                        ) * targetDelta) / observationTimeDelta\\n                    )\\n            );\\n        }\\n    }\\n\\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\n    /// @dev Reverts if `secondsAgos` > oldest observation\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\\n    /// @param tick The current tick\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The current in-range pool liquidity\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\\n    function observe(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32[] memory secondsAgos,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) public view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\\n        require(cardinality > 0, 'I');\\n\\n        tickCumulatives = new int56[](secondsAgos.length);\\n        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\\n        for (uint256 i = 0; i < secondsAgos.length; i++) {\\n            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\\n                self,\\n                time,\\n                secondsAgos[i],\\n                tick,\\n                index,\\n                liquidity,\\n                cardinality\\n            );\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x7990bbf1189774b4aa16fdeb42f4e58483411675eddce57f85d249f0f5a1da72\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x611184610026600b82828239805160001a60731461001957fe5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061008d5760003560e01c8063150b16701461009257806334209030146100bc57806339afed83146100dc57806344108314146100ef5780637b7513c11461010f57806398cdb261146101305780639a7fc6151461015d578063a0eff3f71461017e578063ab329c23146101ac575b600080fd5b6100a56100a0366004610e3c565b6101cc565b6040516100b3929190611113565b60405180910390f35b6100cf6100ca366004610faa565b6103b5565b6040516100b391906110a0565b6100a56100ea366004610e82565b610478565b6101026100fd366004610edf565b610616565b6040516100b391906110ff565b61012261011d366004610d4f565b6106b9565b6040516100b392919061101a565b81801561013c57600080fd5b5061015061014b366004610c6b565b6107fa565b6040516100b3919061112f565b61017061016b366004610e3c565b610884565b6040516100b39291906110ab565b81801561018a57600080fd5b5061019e610199366004610d24565b610a0e565b6040516100b392919061113e565b8180156101b857600080fd5b5061019e6101c7366004610ca6565b610a5a565b6101d4610be0565b6101dc610be0565b888561ffff1661ffff81106101ed57fe5b60408051608081018252919092015463ffffffff8116808352600160201b8204600690810b810b900b6020840152600160581b82046001600160a01b031693830193909352600160f81b900460ff16151560608201529250610251908990896103b5565b15610289578663ffffffff16826000015163ffffffff161415610273576103a9565b8161028083898988610616565b915091506103a9565b888361ffff168660010161ffff168161029e57fe5b0661ffff1661ffff81106102ae57fe5b60408051608081018252929091015463ffffffff81168352600160201b8104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b9091041615156060820181905290925061036357604080516080810182528a5463ffffffff81168252600160201b8104600690810b810b900b6020830152600160581b81046001600160a01b031692820192909252600160f81b90910460ff161515606082015291505b610372888360000151896103b5565b6103975760405162461bcd60e51b815260040161038e906110e2565b60405180910390fd5b6103a48989898887610478565b915091505b97509795505050505050565b60008363ffffffff168363ffffffff16111580156103df57508363ffffffff168263ffffffff1611155b156103fb578163ffffffff168363ffffffff1611159050610471565b60008463ffffffff168463ffffffff1611610422578363ffffffff16600160201b0161042a565b8363ffffffff165b64ffffffffff16905060008563ffffffff168463ffffffff161161045a578363ffffffff16600160201b01610462565b8363ffffffff165b64ffffffffff16909111159150505b9392505050565b610480610be0565b610488610be0565b60008361ffff168560010161ffff168161049e57fe5b0661ffff169050600060018561ffff16830103905060005b506002818301048961ffff871682816104cb57fe5b0661ffff81106104d757fe5b60408051608081018252929091015463ffffffff81168352600160201b8104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b90910416151560608201819052909550610541578060010192506104b6565b898661ffff16826001018161055257fe5b0661ffff811061055e57fe5b60408051608081018252929091015463ffffffff81168352600160201b8104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b909104161515606082015285519094506000906105c8908b908b6103b5565b90508080156105e157506105e18a8a87600001516103b5565b156105ec5750610609565b806105fc57600182039250610603565b8160010193505b506104b6565b5050509550959350505050565b61061e610be0565b600085600001518503905060405180608001604052808663ffffffff1681526020018263ffffffff168660020b0288602001510160060b81526020016000856001600160801b031611610672576001610674565b845b6001600160801b031663ffffffff60801b608085901b168161069257fe5b048860400151016001600160a01b0316815260200160011515815250915050949350505050565b60608060008361ffff16116106e05760405162461bcd60e51b815260040161038e906110c7565b865167ffffffffffffffff811180156106f857600080fd5b50604051908082528060200260200182016040528015610722578160200160208202803683370190505b509150865167ffffffffffffffff8111801561073d57600080fd5b50604051908082528060200260200182016040528015610767578160200160208202803683370190505b50905060005b87518110156107ed576107988a8a8a848151811061078757fe5b60200260200101518a8a8a8a610884565b8483815181106107a457fe5b602002602001018484815181106107b757fe5b60200260200101826001600160a01b03166001600160a01b03168152508260060b60060b8152505050808060010191505061076d565b5097509795505050505050565b6000808361ffff161161081f5760405162461bcd60e51b815260040161038e906110c7565b8261ffff168261ffff1611610835575081610471565b825b8261ffff168161ffff16101561087b576001858261ffff1661ffff811061085a57fe5b01805463ffffffff191663ffffffff92909216919091179055600101610837565b50909392505050565b60008063ffffffff871661092a576000898661ffff1661ffff81106108a557fe5b60408051608081018252919092015463ffffffff808216808452600160201b8304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff16151560608301529092508a161461091657610913818a8988610616565b90505b8060200151816040015192509250506103a9565b86880360008061093f8c8c858c8c8c8c6101cc565b91509150816000015163ffffffff168363ffffffff1614156109715781602001518260400151945094505050506103a9565b805163ffffffff848116911614156109995780602001518160400151945094505050506103a9565b8151815160208085015190840151918390039286039163ffffffff80841692908516910360060b816109c757fe5b05028460200151018263ffffffff168263ffffffff1686604001518660400151036001600160a01b031602816109f957fe5b048560400151019650965050505050506103a9565b6040805160808101825263ffffffff9283168082526000602083018190529282019290925260016060909101819052835463ffffffff1916909117909116600160f81b17909155908190565b6000806000898961ffff1661ffff8110610a7057fe5b60408051608081018252919092015463ffffffff808216808452600160201b8304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff161515606083015290925089161415610adf57888592509250506103a9565b8461ffff168461ffff16118015610b0057506001850361ffff168961ffff16145b15610b0d57839150610b11565b8491505b8161ffff168960010161ffff1681610b2557fe5b069250610b3481898989610616565b8a8461ffff1661ffff8110610b4557fe5b825191018054602084015160408501516060909501511515600160f81b026001600160f81b036001600160a01b03909616600160581b02600160581b600160f81b031960069390930b66ffffffffffffff16600160201b026affffffffffffff000000001963ffffffff90971663ffffffff199095169490941795909516929092171692909217929092161790555097509795505050505050565b60408051608081018252600080825260208201819052918101829052606081019190915290565b80358015158114610c1757600080fd5b919050565b8035600281900b8114610c1757600080fd5b80356001600160801b0381168114610c1757600080fd5b803561ffff81168114610c1757600080fd5b803563ffffffff81168114610c1757600080fd5b600080600060608486031215610c7f578283fd5b83359250610c8f60208501610c45565b9150610c9d60408501610c45565b90509250925092565b600080600080600080600060e0888a031215610cc0578283fd5b87359650610cd060208901610c45565b9550610cde60408901610c57565b9450610cec60608901610c1c565b9350610cfa60808901610c2e565b9250610d0860a08901610c45565b9150610d1660c08901610c45565b905092959891949750929550565b60008060408385031215610d36578182fd5b82359150610d4660208401610c57565b90509250929050565b600080600080600080600060e0888a031215610d69578283fd5b873596506020610d7a818a01610c57565b9650604089013567ffffffffffffffff80821115610d96578586fd5b818b0191508b601f830112610da9578586fd5b813581811115610db557fe5b8381029150610dc5848301611153565b8082825285820191508585018f87868801011115610de157898afd5b8995505b83861015610e0a57610df681610c57565b835260019590950194918601918601610de5565b50809a50505050505050610e2060608901610c1c565b9350610e2e60808901610c45565b9250610d0860a08901610c2e565b600080600080600080600060e0888a031215610e56578283fd5b87359650610e6660208901610c57565b9550610e7460408901610c57565b9450610e2060608901610c1c565b600080600080600060a08688031215610e99578081fd5b85359450610ea960208701610c57565b9350610eb760408701610c57565b9250610ec560608701610c45565b9150610ed360808701610c45565b90509295509295909350565b60008060008084860360e0811215610ef5578283fd5b6080811215610f02578283fd5b506040516080810181811067ffffffffffffffff82111715610f2057fe5b604052610f2c86610c57565b815260208601358060060b8114610f41578384fd5b602082015260408601356001600160a01b0381168114610f5f578384fd5b6040820152610f7060608701610c07565b60608201529350610f8360808601610c57565b9250610f9160a08601610c1c565b9150610f9f60c08601610c2e565b905092959194509250565b600080600060608486031215610fbe578081fd5b610fc784610c57565b9250610fd560208501610c57565b9150610c9d60408501610c57565b805163ffffffff16825260208082015160060b908301526040808201516001600160a01b0316908301526060908101511515910152565b604080825283519082018190526000906020906060840190828701845b8281101561105657815160060b84529284019290840190600101611037565b50505083810382850152845180825285830191830190845b818110156110935783516001600160a01b03168352928401929184019160010161106e565b5090979650505050505050565b901515815260200190565b60069290920b82526001600160a01b0316602082015260400190565b6020808252600190820152604960f81b604082015260600190565b60208082526003908201526213d31160ea1b604082015260600190565b6080810161110d8284610fe3565b92915050565b61010081016111228285610fe3565b6104716080830184610fe3565b61ffff91909116815260200190565b61ffff92831681529116602082015260400190565b60405181810167ffffffffffffffff8111828210171561116f57fe5b60405291905056fea164736f6c6343000706000a",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061008d5760003560e01c8063150b16701461009257806334209030146100bc57806339afed83146100dc57806344108314146100ef5780637b7513c11461010f57806398cdb261146101305780639a7fc6151461015d578063a0eff3f71461017e578063ab329c23146101ac575b600080fd5b6100a56100a0366004610e3c565b6101cc565b6040516100b3929190611113565b60405180910390f35b6100cf6100ca366004610faa565b6103b5565b6040516100b391906110a0565b6100a56100ea366004610e82565b610478565b6101026100fd366004610edf565b610616565b6040516100b391906110ff565b61012261011d366004610d4f565b6106b9565b6040516100b392919061101a565b81801561013c57600080fd5b5061015061014b366004610c6b565b6107fa565b6040516100b3919061112f565b61017061016b366004610e3c565b610884565b6040516100b39291906110ab565b81801561018a57600080fd5b5061019e610199366004610d24565b610a0e565b6040516100b392919061113e565b8180156101b857600080fd5b5061019e6101c7366004610ca6565b610a5a565b6101d4610be0565b6101dc610be0565b888561ffff1661ffff81106101ed57fe5b60408051608081018252919092015463ffffffff8116808352600160201b8204600690810b810b900b6020840152600160581b82046001600160a01b031693830193909352600160f81b900460ff16151560608201529250610251908990896103b5565b15610289578663ffffffff16826000015163ffffffff161415610273576103a9565b8161028083898988610616565b915091506103a9565b888361ffff168660010161ffff168161029e57fe5b0661ffff1661ffff81106102ae57fe5b60408051608081018252929091015463ffffffff81168352600160201b8104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b9091041615156060820181905290925061036357604080516080810182528a5463ffffffff81168252600160201b8104600690810b810b900b6020830152600160581b81046001600160a01b031692820192909252600160f81b90910460ff161515606082015291505b610372888360000151896103b5565b6103975760405162461bcd60e51b815260040161038e906110e2565b60405180910390fd5b6103a48989898887610478565b915091505b97509795505050505050565b60008363ffffffff168363ffffffff16111580156103df57508363ffffffff168263ffffffff1611155b156103fb578163ffffffff168363ffffffff1611159050610471565b60008463ffffffff168463ffffffff1611610422578363ffffffff16600160201b0161042a565b8363ffffffff165b64ffffffffff16905060008563ffffffff168463ffffffff161161045a578363ffffffff16600160201b01610462565b8363ffffffff165b64ffffffffff16909111159150505b9392505050565b610480610be0565b610488610be0565b60008361ffff168560010161ffff168161049e57fe5b0661ffff169050600060018561ffff16830103905060005b506002818301048961ffff871682816104cb57fe5b0661ffff81106104d757fe5b60408051608081018252929091015463ffffffff81168352600160201b8104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b90910416151560608201819052909550610541578060010192506104b6565b898661ffff16826001018161055257fe5b0661ffff811061055e57fe5b60408051608081018252929091015463ffffffff81168352600160201b8104600690810b810b900b60208401526001600160a01b03600160581b8204169183019190915260ff600160f81b909104161515606082015285519094506000906105c8908b908b6103b5565b90508080156105e157506105e18a8a87600001516103b5565b156105ec5750610609565b806105fc57600182039250610603565b8160010193505b506104b6565b5050509550959350505050565b61061e610be0565b600085600001518503905060405180608001604052808663ffffffff1681526020018263ffffffff168660020b0288602001510160060b81526020016000856001600160801b031611610672576001610674565b845b6001600160801b031663ffffffff60801b608085901b168161069257fe5b048860400151016001600160a01b0316815260200160011515815250915050949350505050565b60608060008361ffff16116106e05760405162461bcd60e51b815260040161038e906110c7565b865167ffffffffffffffff811180156106f857600080fd5b50604051908082528060200260200182016040528015610722578160200160208202803683370190505b509150865167ffffffffffffffff8111801561073d57600080fd5b50604051908082528060200260200182016040528015610767578160200160208202803683370190505b50905060005b87518110156107ed576107988a8a8a848151811061078757fe5b60200260200101518a8a8a8a610884565b8483815181106107a457fe5b602002602001018484815181106107b757fe5b60200260200101826001600160a01b03166001600160a01b03168152508260060b60060b8152505050808060010191505061076d565b5097509795505050505050565b6000808361ffff161161081f5760405162461bcd60e51b815260040161038e906110c7565b8261ffff168261ffff1611610835575081610471565b825b8261ffff168161ffff16101561087b576001858261ffff1661ffff811061085a57fe5b01805463ffffffff191663ffffffff92909216919091179055600101610837565b50909392505050565b60008063ffffffff871661092a576000898661ffff1661ffff81106108a557fe5b60408051608081018252919092015463ffffffff808216808452600160201b8304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff16151560608301529092508a161461091657610913818a8988610616565b90505b8060200151816040015192509250506103a9565b86880360008061093f8c8c858c8c8c8c6101cc565b91509150816000015163ffffffff168363ffffffff1614156109715781602001518260400151945094505050506103a9565b805163ffffffff848116911614156109995780602001518160400151945094505050506103a9565b8151815160208085015190840151918390039286039163ffffffff80841692908516910360060b816109c757fe5b05028460200151018263ffffffff168263ffffffff1686604001518660400151036001600160a01b031602816109f957fe5b048560400151019650965050505050506103a9565b6040805160808101825263ffffffff9283168082526000602083018190529282019290925260016060909101819052835463ffffffff1916909117909116600160f81b17909155908190565b6000806000898961ffff1661ffff8110610a7057fe5b60408051608081018252919092015463ffffffff808216808452600160201b8304600690810b810b900b6020850152600160581b83046001600160a01b031694840194909452600160f81b90910460ff161515606083015290925089161415610adf57888592509250506103a9565b8461ffff168461ffff16118015610b0057506001850361ffff168961ffff16145b15610b0d57839150610b11565b8491505b8161ffff168960010161ffff1681610b2557fe5b069250610b3481898989610616565b8a8461ffff1661ffff8110610b4557fe5b825191018054602084015160408501516060909501511515600160f81b026001600160f81b036001600160a01b03909616600160581b02600160581b600160f81b031960069390930b66ffffffffffffff16600160201b026affffffffffffff000000001963ffffffff90971663ffffffff199095169490941795909516929092171692909217929092161790555097509795505050505050565b60408051608081018252600080825260208201819052918101829052606081019190915290565b80358015158114610c1757600080fd5b919050565b8035600281900b8114610c1757600080fd5b80356001600160801b0381168114610c1757600080fd5b803561ffff81168114610c1757600080fd5b803563ffffffff81168114610c1757600080fd5b600080600060608486031215610c7f578283fd5b83359250610c8f60208501610c45565b9150610c9d60408501610c45565b90509250925092565b600080600080600080600060e0888a031215610cc0578283fd5b87359650610cd060208901610c45565b9550610cde60408901610c57565b9450610cec60608901610c1c565b9350610cfa60808901610c2e565b9250610d0860a08901610c45565b9150610d1660c08901610c45565b905092959891949750929550565b60008060408385031215610d36578182fd5b82359150610d4660208401610c57565b90509250929050565b600080600080600080600060e0888a031215610d69578283fd5b873596506020610d7a818a01610c57565b9650604089013567ffffffffffffffff80821115610d96578586fd5b818b0191508b601f830112610da9578586fd5b813581811115610db557fe5b8381029150610dc5848301611153565b8082825285820191508585018f87868801011115610de157898afd5b8995505b83861015610e0a57610df681610c57565b835260019590950194918601918601610de5565b50809a50505050505050610e2060608901610c1c565b9350610e2e60808901610c45565b9250610d0860a08901610c2e565b600080600080600080600060e0888a031215610e56578283fd5b87359650610e6660208901610c57565b9550610e7460408901610c57565b9450610e2060608901610c1c565b600080600080600060a08688031215610e99578081fd5b85359450610ea960208701610c57565b9350610eb760408701610c57565b9250610ec560608701610c45565b9150610ed360808701610c45565b90509295509295909350565b60008060008084860360e0811215610ef5578283fd5b6080811215610f02578283fd5b506040516080810181811067ffffffffffffffff82111715610f2057fe5b604052610f2c86610c57565b815260208601358060060b8114610f41578384fd5b602082015260408601356001600160a01b0381168114610f5f578384fd5b6040820152610f7060608701610c07565b60608201529350610f8360808601610c57565b9250610f9160a08601610c1c565b9150610f9f60c08601610c2e565b905092959194509250565b600080600060608486031215610fbe578081fd5b610fc784610c57565b9250610fd560208501610c57565b9150610c9d60408501610c57565b805163ffffffff16825260208082015160060b908301526040808201516001600160a01b0316908301526060908101511515910152565b604080825283519082018190526000906020906060840190828701845b8281101561105657815160060b84529284019290840190600101611037565b50505083810382850152845180825285830191830190845b818110156110935783516001600160a01b03168352928401929184019160010161106e565b5090979650505050505050565b901515815260200190565b60069290920b82526001600160a01b0316602082015260400190565b6020808252600190820152604960f81b604082015260600190565b60208082526003908201526213d31160ea1b604082015260600190565b6080810161110d8284610fe3565b92915050565b61010081016111228285610fe3565b6104716080830184610fe3565b61ffff91909116815260200190565b61ffff92831681529116602082015260400190565b60405181810167ffffffffffffffff8111828210171561116f57fe5b60405291905056fea164736f6c6343000706000a",
  "devdoc": {
    "details": "Instances of stored oracle data, \"observations\", are collected in the oracle array Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the maximum length of the oracle array. New slots will be added when the array is fully populated. Observations are overwritten when the full length of the oracle array is populated. The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()",
    "kind": "dev",
    "methods": {
      "binarySearch(Oracle.Observation[65535] storage,uint32,uint32,uint16,uint16)": {
        "details": "The answer must be contained in the array, used when the target is located within the stored observation boundaries: older than the most recent observation and younger, or the same age as, the oldest observation",
        "params": {
          "cardinality": "The number of populated elements in the oracle array",
          "index": "The index of the observation that was most recently written to the observations array",
          "self": "The stored oracle array",
          "target": "The timestamp at which the reserved observation should be for",
          "time": "The current block.timestamp"
        },
        "returns": {
          "atOrAfter": "The observation recorded at, or after, the target",
          "beforeOrAt": "The observation recorded before, or at, the target"
        }
      },
      "getSurroundingObservations(Oracle.Observation[65535] storage,uint32,uint32,int24,uint16,uint128,uint16)": {
        "details": "Assumes there is at least 1 initialized observation. Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.",
        "params": {
          "cardinality": "The number of populated elements in the oracle array",
          "index": "The index of the observation that was most recently written to the observations array",
          "liquidity": "The total pool liquidity at the time of the call",
          "self": "The stored oracle array",
          "target": "The timestamp at which the reserved observation should be for",
          "tick": "The active tick at the time of the returned or simulated observation",
          "time": "The current block.timestamp"
        },
        "returns": {
          "atOrAfter": "The observation which occurred at, or after, the given timestamp",
          "beforeOrAt": "The observation which occurred at, or before, the given timestamp"
        }
      },
      "grow(Oracle.Observation[65535] storage,uint16,uint16)": {
        "params": {
          "current": "The current next cardinality of the oracle array",
          "next": "The proposed next cardinality which will be populated in the oracle array",
          "self": "The stored oracle array"
        },
        "returns": {
          "_0": "next The next cardinality which will be populated in the oracle array"
        }
      },
      "initialize(Oracle.Observation[65535] storage,uint32)": {
        "params": {
          "self": "The stored oracle array",
          "time": "The time of the oracle initialization, via block.timestamp truncated to uint32"
        },
        "returns": {
          "cardinality": "The number of populated elements in the oracle array",
          "cardinalityNext": "The new length of the oracle array, independent of population"
        }
      },
      "lte(uint32,uint32,uint32)": {
        "details": "safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time",
        "params": {
          "a": "A comparison timestamp from which to determine the relative position of `time`",
          "b": "From which to determine the relative position of `time`",
          "time": "A timestamp truncated to 32 bits"
        },
        "returns": {
          "_0": "bool Whether `a` is chronologically <= `b`"
        }
      },
      "observe(Oracle.Observation[65535] storage,uint32,uint32[],int24,uint16,uint128,uint16)": {
        "details": "Reverts if `secondsAgos` > oldest observation",
        "params": {
          "cardinality": "The number of populated elements in the oracle array",
          "index": "The index of the observation that was most recently written to the observations array",
          "liquidity": "The current in-range pool liquidity",
          "secondsAgos": "Each amount of time to look back, in seconds, at which point to return an observation",
          "self": "The stored oracle array",
          "tick": "The current tick",
          "time": "The current block.timestamp"
        },
        "returns": {
          "secondsPerLiquidityCumulativeX128s": "The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`",
          "tickCumulatives": "The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`"
        }
      },
      "observeSingle(Oracle.Observation[65535] storage,uint32,uint32,int24,uint16,uint128,uint16)": {
        "details": "Reverts if an observation at or before the desired observation timestamp does not exist. 0 may be passed as `secondsAgo' to return the current cumulative values. If called with a timestamp falling between two observations, returns the counterfactual accumulator values at exactly the timestamp between the two observations.",
        "params": {
          "cardinality": "The number of populated elements in the oracle array",
          "index": "The index of the observation that was most recently written to the observations array",
          "liquidity": "The current in-range pool liquidity",
          "secondsAgo": "The amount of time to look back, in seconds, at which point to return an observation",
          "self": "The stored oracle array",
          "tick": "The current tick",
          "time": "The current block timestamp"
        },
        "returns": {
          "secondsPerLiquidityCumulativeX128": "The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`",
          "tickCumulative": "The tick * time elapsed since the pool was first initialized, as of `secondsAgo`"
        }
      },
      "transform(Oracle.Observation,uint32,int24,uint128)": {
        "details": "blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows",
        "params": {
          "blockTimestamp": "The timestamp of the new observation",
          "last": "The specified observation to be transformed",
          "liquidity": "The total in-range liquidity at the time of the new observation",
          "tick": "The active tick at the time of the new observation"
        },
        "returns": {
          "_0": "Observation The newly populated observation"
        }
      },
      "write(Oracle.Observation[65535] storage,uint16,uint32,int24,uint128,uint16,uint16)": {
        "details": "Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally. If the index is at the end of the allowable array length (according to cardinality), and the next cardinality is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.",
        "params": {
          "blockTimestamp": "The timestamp of the new observation",
          "cardinality": "The number of populated elements in the oracle array",
          "cardinalityNext": "The new length of the oracle array, independent of population",
          "index": "The index of the observation that was most recently written to the observations array",
          "liquidity": "The total in-range liquidity at the time of the new observation",
          "self": "The stored oracle array",
          "tick": "The active tick at the time of the new observation"
        },
        "returns": {
          "cardinalityUpdated": "The new cardinality of the oracle array",
          "indexUpdated": "The new index of the most recently written element in the oracle array"
        }
      }
    },
    "title": "Oracle",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "binarySearch(Oracle.Observation[65535] storage,uint32,uint32,uint16,uint16)": {
        "notice": "Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied. The result may be the same observation, or adjacent observations."
      },
      "getSurroundingObservations(Oracle.Observation[65535] storage,uint32,uint32,int24,uint16,uint128,uint16)": {
        "notice": "Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied"
      },
      "grow(Oracle.Observation[65535] storage,uint16,uint16)": {
        "notice": "Prepares the oracle array to store up to `next` observations"
      },
      "initialize(Oracle.Observation[65535] storage,uint32)": {
        "notice": "Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array"
      },
      "lte(uint32,uint32,uint32)": {
        "notice": "comparator for 32-bit timestamps"
      },
      "observe(Oracle.Observation[65535] storage,uint32,uint32[],int24,uint16,uint128,uint16)": {
        "notice": "Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`"
      },
      "transform(Oracle.Observation,uint32,int24,uint128)": {
        "notice": "Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values"
      },
      "write(Oracle.Observation[65535] storage,uint16,uint32,int24,uint128,uint16,uint16)": {
        "notice": "Writes an oracle observation to the array"
      }
    },
    "notice": "Provides price and liquidity data useful for a wide variety of system designs",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}